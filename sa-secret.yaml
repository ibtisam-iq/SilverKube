# ===============================
# 1. ServiceAccount Definition
# ===============================
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-serviceaccount              # Name of this ServiceAccount
  namespace: my-namespace              # Namespace scope (SAs are namespaced resources!)
  labels:
    app.kubernetes.io/name: my-app
  annotations:
    kubernetes.io/description: "ServiceAccount for my-app workloads"

# ⚡ KEY FIELD:
automountServiceAccountToken: true     # -> Default is true
                                       # If true:
                                       #   Every Pod using this SA will get a token mounted at:
                                       #   /var/run/secrets/kubernetes.io/serviceaccount/token
                                       # If false:
                                       #   Pods won't automatically get the token, but you can still manually mount it.

# ⚡ OPTIONAL FIELD:
imagePullSecrets:                      # -> Lets this SA pull from private registries
  - name: my-dockerhub-secret
  - name: ecr-secret                   # These must already exist as Secrets of type kubernetes.io/dockerconfigjson

# ⚡ OPTIONAL FIELD:
secrets:                               # -> Explicitly attach extra secrets to the SA
  - name: custom-secret                # Example: could hold API keys, TLS certs, etc.
                                       # Difference:
                                       # - imagePullSecrets → only used by kubelet for pulling images
                                       # - secrets → available for Pods to mount via SA
---
# ===============================
# 2. Secret Bound to ServiceAccount
# ===============================
apiVersion: v1
kind: Secret
metadata:
  name: my-serviceaccount-token        # Secret name (usually auto-generated by Kubernetes!)
  namespace: my-namespace
  annotations:
    kubernetes.io/service-account.name: "my-serviceaccount"
                                       # ^ This annotation is the LINK between the Secret and the SA.
                                       #   It tells Kubernetes: "This Secret belongs to that SA".
type: kubernetes.io/service-account-token
                                       # ^ Special Secret type: holds a JWT token + CA cert + namespace.
                                       #   Example files inside the Secret's data:
                                       #   - token (JWT used for API authentication)
                                       #   - ca.crt (cluster root CA cert, so Pods can validate kube-apiserver)
                                       #   - namespace (the namespace the Pod runs in)

# ⚡ IMPORTANT NOTES about ServiceAccounts and Secrets:
# 1. If automountServiceAccountToken=true (default):
#    - Kubernetes AUTOMATICALLY creates a Secret of type "kubernetes.io/service-account-token".
#    - This Secret is auto-mounted into Pods that use the ServiceAccount.
#
# 2. If automountServiceAccountToken=false:
#    - Kubernetes will still create the token Secret for the SA (so the Secret exists),
#      BUT it will NOT be automatically mounted into Pods.
#    - You can still manually mount it by referencing the Secret in the Pod spec.
#
# 3. If you delete the Secret manually:
#    - Kubernetes will re-create a new one (auto-managed).
#    - That’s why you almost never define token Secrets yourself — they’re system-managed.
#
# 4. secrets[] field in the SA:
#    - You can attach *extra* Secrets (not token ones) here.
#    - These will NOT be auto-mounted; Pods must mount them explicitly via "volumes".
#
# 5. imagePullSecrets[] vs secrets[]:
#    - imagePullSecrets are used by kubelet ONLY during image pulls.
#    - secrets[] are more general and can be mounted into Pods as files/env vars.
#
# 6. ServiceAccount token lifetime:
#    - In older K8s (<1.24), these Secrets contained long-lived tokens.
#    - In newer K8s (>=1.24), tokens are short-lived & projected, but
#      the Secret object still exists for backward compatibility.
